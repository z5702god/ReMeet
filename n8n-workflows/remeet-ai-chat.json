{
  "name": "ReMeet AI Chat",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/chat",
        "responseMode": "responseNode",
        "options": {
          "rawBody": false
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook - Chat API",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "remeet-chat"
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// JWT TOKEN VALIDATION & INPUT EXTRACTION\n// ===========================================\n// Security: Validate Supabase JWT and extract user_id from token\n// This prevents user_id spoofing attacks\n\n// Get request data\nconst headers = $input.first().json.headers;\nconst body = $input.first().json.body;\n\n// Extract Authorization header\nconst authHeader = headers.authorization || headers.Authorization || '';\nconst token = authHeader.replace('Bearer ', '');\n\nif (!token) {\n  throw new Error('Missing Authorization header. Please provide a valid Supabase JWT token.');\n}\n\n// Decode JWT (without full verification - Supabase handles that)\n// In production, you should verify the signature using Supabase JWT secret\ntry {\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw new Error('Invalid JWT format');\n  }\n  \n  // Decode payload (base64url to base64, then decode)\n  const base64Payload = parts[1].replace(/-/g, '+').replace(/_/g, '/');\n  const payload = JSON.parse(Buffer.from(base64Payload, 'base64').toString('utf8'));\n  \n  // Check expiration\n  const now = Math.floor(Date.now() / 1000);\n  if (payload.exp && payload.exp < now) {\n    throw new Error('JWT token has expired');\n  }\n  \n  // Extract user_id from 'sub' claim (Supabase standard)\n  const user_id = payload.sub;\n  if (!user_id) {\n    throw new Error('Invalid JWT: missing sub claim');\n  }\n  \n  // Validate UUID format to prevent injection\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n  if (!uuidRegex.test(user_id)) {\n    throw new Error('Invalid user_id format');\n  }\n  \n  return [{\n    json: {\n      user_id: user_id,\n      message: body.message || '',\n      today: new Date().toISOString().split('T')[0],\n      jwt_valid: true\n    }\n  }];\n  \n} catch (e) {\n  throw new Error('JWT validation failed: ' + e.message);\n}"
      },
      "id": "validate-jwt",
      "name": "Validate JWT & Extract Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0,
          "maxTokens": 500
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "你是 ReMeet app 的 AI 助手，專門幫用戶查找他們的商務聯絡人。\n\n根據用戶的訊息，分析他們的意圖並輸出 JSON 格式：\n\n```json\n{\n  \"intent\": \"search_contact\" | \"list_recent\" | \"search_by_event\" | \"search_by_company\" | \"search_by_location\" | \"search_by_date\" | \"need_followup\" | \"general_question\",\n  \"search_params\": {\n    \"name\": \"姓名關鍵字（如有）\",\n    \"company\": \"公司名關鍵字（如有）\",\n    \"location\": \"地點關鍵字（如有）\",\n    \"event_name\": \"活動名稱（如有）\",\n    \"date_start\": \"YYYY-MM-DD（如有時間範圍）\",\n    \"date_end\": \"YYYY-MM-DD（如有時間範圍）\"\n  },\n  \"requires_db_query\": true,\n  \"user_language\": \"zh\" | \"en\"\n}\n```\n\n重要規則：\n1. 任何提到時間的訊息（上個月、這個月、最近、上週等），intent 必須是 \"search_by_date\"，requires_db_query 必須是 true，且必須填入正確的 date_start 和 date_end\n2. 「上個月」= 上個月的第一天到最後一天\n3. 「最近」= 過去 30 天\n4. 「上週」= 過去 7 天\n5. 「這個月」= 這個月的第一天到今天\n6. 如果用戶用中文，設 user_language 為 \"zh\"；用英文則設為 \"en\"\n7. 只輸出 JSON，不要有其他文字\n\n範例（假設今天是 2026-02-13）：\n輸入：「上個月認識的人」\n輸出：{\"intent\":\"search_by_date\",\"search_params\":{\"name\":\"\",\"company\":\"\",\"location\":\"\",\"event_name\":\"\",\"date_start\":\"2026-01-01\",\"date_end\":\"2026-01-31\"},\"requires_db_query\":true,\"user_language\":\"zh\"}\n\n輸入：「這個月認識的人」\n輸出：{\"intent\":\"search_by_date\",\"search_params\":{\"name\":\"\",\"company\":\"\",\"location\":\"\",\"event_name\":\"\",\"date_start\":\"2026-02-01\",\"date_end\":\"2026-02-13\"},\"requires_db_query\":true,\"user_language\":\"zh\"}"
            },
            {
              "role": "user",
              "content": "今天日期是 {{ $json.today }}。\n\n用戶訊息：{{ $json.message }}"
            }
          ]
        }
      },
      "id": "openai-intent",
      "name": "OpenAI - Analyze Intent",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.5,
      "position": [680, 300],
      "credentials": {
        "openAiApi": {
          "id": "So0TGwMDsXWcYGBb",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PARSE INTENT & SANITIZE SEARCH PARAMS\n// ===========================================\n\nconst response = $input.first().json;\nlet intentData;\n\ntry {\n  let content = response.message?.content || response.choices?.[0]?.message?.content || '';\n  content = content.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  intentData = JSON.parse(content);\n} catch (e) {\n  intentData = {\n    intent: 'list_all',\n    search_params: {},\n    requires_db_query: true,\n    user_language: 'zh'\n  };\n}\n\nconst originalInput = $('Validate JWT & Extract Input').first().json;\n\nfunction sanitizeInput(input) {\n  if (!input || typeof input !== 'string') return null;\n  let sanitized = input\n    .replaceAll(\"'\", '')\n    .replaceAll('\"', '')\n    .replaceAll(';', '')\n    .replaceAll('--', '')\n    .replaceAll('/*', '')\n    .replaceAll('*/', '')\n    .trim();\n  if (sanitized.length > 100) sanitized = sanitized.substring(0, 100);\n  return sanitized || null;\n}\n\nfunction sanitizeDate(dateStr) {\n  if (!dateStr || typeof dateStr !== 'string') return null;\n  const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!dateRegex.test(dateStr)) return null;\n  const date = new Date(dateStr);\n  if (isNaN(date.getTime())) return null;\n  return dateStr;\n}\n\nfunction sanitizeArray(arr) {\n  if (!Array.isArray(arr)) return [];\n  return arr.map(sanitizeInput).filter(Boolean);\n}\n\nconst searchParams = intentData.search_params || {};\nconst sanitizedParams = {\n  name: sanitizeInput(searchParams.name),\n  name_variants: sanitizeArray(searchParams.name_variants),\n  company: sanitizeInput(searchParams.company),\n  company_variants: sanitizeArray(searchParams.company_variants),\n  location: sanitizeInput(searchParams.location),\n  event_name: sanitizeInput(searchParams.event_name),\n  date_start: sanitizeDate(searchParams.date_start),\n  date_end: sanitizeDate(searchParams.date_end),\n  date_type: searchParams.date_type === 'meeting' ? 'meeting' : 'created',\n  keywords: sanitizeArray(searchParams.keywords)\n};\n\n// ===========================================\n// DATE KEYWORD FALLBACK\n// ===========================================\n// If GPT didn't provide dates but message contains time keywords,\n// compute dates programmatically to guarantee correctness\nconst msg = originalInput.message || '';\nconst today = new Date(originalInput.today + 'T00:00:00Z');\nlet intent = intentData.intent;\nlet requiresDbQuery = intentData.requires_db_query !== false;\n\nif (!sanitizedParams.date_start && !sanitizedParams.date_end) {\n  const year = today.getUTCFullYear();\n  const month = today.getUTCMonth();\n\n  if (msg.includes('上個月') || msg.includes('上月')) {\n    const lastMonth = month === 0 ? 11 : month - 1;\n    const lastMonthYear = month === 0 ? year - 1 : year;\n    const lastDay = new Date(Date.UTC(lastMonthYear, lastMonth + 1, 0)).getUTCDate();\n    sanitizedParams.date_start = `${lastMonthYear}-${String(lastMonth + 1).padStart(2, '0')}-01`;\n    sanitizedParams.date_end = `${lastMonthYear}-${String(lastMonth + 1).padStart(2, '0')}-${String(lastDay).padStart(2, '0')}`;\n    intent = 'search_by_date';\n    requiresDbQuery = true;\n  } else if (msg.includes('這個月') || msg.includes('本月')) {\n    sanitizedParams.date_start = `${year}-${String(month + 1).padStart(2, '0')}-01`;\n    sanitizedParams.date_end = originalInput.today;\n    intent = 'search_by_date';\n    requiresDbQuery = true;\n  } else if (msg.includes('上週') || msg.includes('上禮拜') || msg.includes('上星期')) {\n    const weekAgo = new Date(today);\n    weekAgo.setUTCDate(weekAgo.getUTCDate() - 7);\n    sanitizedParams.date_start = weekAgo.toISOString().split('T')[0];\n    sanitizedParams.date_end = originalInput.today;\n    intent = 'search_by_date';\n    requiresDbQuery = true;\n  } else if (msg.includes('最近')) {\n    const monthAgo = new Date(today);\n    monthAgo.setUTCDate(monthAgo.getUTCDate() - 30);\n    sanitizedParams.date_start = monthAgo.toISOString().split('T')[0];\n    sanitizedParams.date_end = originalInput.today;\n    intent = 'search_by_date';\n    requiresDbQuery = true;\n  } else if (msg.includes('今年')) {\n    sanitizedParams.date_start = `${year}-01-01`;\n    sanitizedParams.date_end = originalInput.today;\n    intent = 'search_by_date';\n    requiresDbQuery = true;\n  } else if (msg.includes('去年')) {\n    sanitizedParams.date_start = `${year - 1}-01-01`;\n    sanitizedParams.date_end = `${year - 1}-12-31`;\n    intent = 'search_by_date';\n    requiresDbQuery = true;\n  }\n}\n\nreturn [{\n  json: {\n    user_id: originalInput.user_id,\n    message: originalInput.message,\n    today: originalInput.today,\n    intent: intent,\n    search_params: sanitizedParams,\n    requires_db_query: requiresDbQuery,\n    user_language: intentData.user_language || 'zh'\n  }\n}];"
      },
      "id": "parse-intent",
      "name": "Parse Intent & Sanitize",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// BUILD SAFE QUERY WITH INLINE VALUES\n// ===========================================\n// Security: All inputs have been sanitized in previous step\n// user_id is validated as UUID, other params have dangerous chars removed\n\nconst data = $input.first().json;\n\n// Escape single quotes for SQL safety (double them)\nfunction escapeSql(str) {\n  if (!str) return null;\n  return str.replace(/'/g, \"''\");\n}\n\n// Build the query with inline values (already sanitized)\nconst userId = escapeSql(data.user_id);\n\nlet query = `\nWITH contact_data AS (\n  SELECT \n    c.id,\n    c.full_name,\n    c.title,\n    c.email,\n    c.phone,\n    c.is_favorite,\n    c.created_at,\n    co.name as company_name,\n    co.industry as company_industry\n  FROM contacts c\n  LEFT JOIN companies co ON c.company_id = co.id\n  WHERE c.user_id = '${userId}'::uuid\n),\nmeeting_data AS (\n  SELECT \n    mc.contact_id,\n    mc.meeting_date,\n    mc.location_name,\n    mc.event_name,\n    mc.occasion_type,\n    mc.relationship_type,\n    mc.notes,\n    mc.follow_up_required,\n    mc.follow_up_date\n  FROM meeting_contexts mc\n  WHERE mc.user_id = '${userId}'::uuid\n)\nSELECT \n  cd.*,\n  md.meeting_date,\n  md.location_name,\n  md.event_name,\n  md.occasion_type,\n  md.relationship_type,\n  md.notes as meeting_notes,\n  md.follow_up_required,\n  md.follow_up_date\nFROM contact_data cd\nLEFT JOIN meeting_data md ON cd.id = md.contact_id\nWHERE 1=1\n`;\n\n// Add optional filters with escaped values\nif (data.search_params.name) {\n  query += ` AND cd.full_name ILIKE '%${escapeSql(data.search_params.name)}%'`;\n}\n\nif (data.search_params.company) {\n  query += ` AND cd.company_name ILIKE '%${escapeSql(data.search_params.company)}%'`;\n}\n\nif (data.search_params.location) {\n  query += ` AND md.location_name ILIKE '%${escapeSql(data.search_params.location)}%'`;\n}\n\nif (data.search_params.event_name) {\n  query += ` AND md.event_name ILIKE '%${escapeSql(data.search_params.event_name)}%'`;\n}\n\n// Date filtering: check meeting_date first, fallback to created_at\nif (data.search_params.date_start && data.search_params.date_end) {\n  query += ` AND (\n    (md.meeting_date >= '${escapeSql(data.search_params.date_start)}'::date AND md.meeting_date <= '${escapeSql(data.search_params.date_end)}'::date)\n    OR\n    (md.meeting_date IS NULL AND cd.created_at >= '${escapeSql(data.search_params.date_start)}'::date AND cd.created_at < ('${escapeSql(data.search_params.date_end)}'::date + interval '1 day'))\n  )`;\n} else if (data.search_params.date_start) {\n  query += ` AND (\n    md.meeting_date >= '${escapeSql(data.search_params.date_start)}'::date\n    OR\n    (md.meeting_date IS NULL AND cd.created_at >= '${escapeSql(data.search_params.date_start)}'::date)\n  )`;\n} else if (data.search_params.date_end) {\n  query += ` AND (\n    md.meeting_date <= '${escapeSql(data.search_params.date_end)}'::date\n    OR\n    (md.meeting_date IS NULL AND cd.created_at < ('${escapeSql(data.search_params.date_end)}'::date + interval '1 day'))\n  )`;\n}\n\nif (data.intent === 'need_followup') {\n  query += ` AND md.follow_up_required = true`;\n}\n\nquery += `\nORDER BY \n  CASE WHEN md.meeting_date IS NOT NULL THEN md.meeting_date ELSE cd.created_at END DESC\nLIMIT 20`;\n\nreturn [{\n  json: {\n    ...data,\n    query: query\n  }\n}];"
      },
      "id": "build-query",
      "name": "Build Parameterized Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.query }}"
      },
      "id": "supabase-query",
      "name": "Supabase - Query Contacts",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1340, 300],
      "credentials": {
        "postgres": {
          "id": "WjqzcbGnUEsK5Wxs",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for response generation\nconst intentData = $('Build Parameterized Query').first().json;\nconst queryResults = $input.all().map(item => item.json);\n\n// Deduplicate contacts (may have multiple meeting contexts)\nconst contactMap = new Map();\nfor (const row of queryResults) {\n  if (!row.id) continue;\n  \n  if (!contactMap.has(row.id)) {\n    contactMap.set(row.id, {\n      id: row.id,\n      full_name: row.full_name,\n      title: row.title,\n      email: row.email,\n      phone: row.phone,\n      company_name: row.company_name,\n      is_favorite: row.is_favorite,\n      meeting_contexts: []\n    });\n  }\n  \n  if (row.meeting_date || row.event_name || row.location_name) {\n    contactMap.get(row.id).meeting_contexts.push({\n      meeting_date: row.meeting_date,\n      location_name: row.location_name,\n      event_name: row.event_name,\n      occasion_type: row.occasion_type,\n      relationship_type: row.relationship_type,\n      notes: row.meeting_notes,\n      follow_up_required: row.follow_up_required,\n      follow_up_date: row.follow_up_date\n    });\n  }\n}\n\nconst contacts = Array.from(contactMap.values());\n\nreturn [{\n  json: {\n    user_id: intentData.user_id,\n    message: intentData.message,\n    intent: intentData.intent,\n    search_params: intentData.search_params,\n    user_language: intentData.user_language,\n    contacts: contacts,\n    contact_count: contacts.length\n  }\n}];"
      },
      "id": "prepare-response",
      "name": "Prepare Response Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build final API response - 直接返回名片資料，不使用 AI 生成回覆\nconst preparedData = $input.first().json;\n\n// Format contacts for iOS app\nconst formattedContacts = preparedData.contacts.map(c => ({\n  id: c.id,\n  full_name: c.full_name,\n  title: c.title,\n  email: c.email,\n  phone: c.phone,\n  company_name: c.company_name,\n  is_favorite: c.is_favorite,\n  meeting_context: c.meeting_contexts?.[0] ? {\n    date: c.meeting_contexts[0].meeting_date,\n    location: c.meeting_contexts[0].location_name,\n    event: c.meeting_contexts[0].event_name,\n    occasion_type: c.meeting_contexts[0].occasion_type,\n    relationship_type: c.meeting_contexts[0].relationship_type\n  } : null\n}));\n\n// 根據語言和結果數量生成簡單回覆\nconst lang = preparedData.user_language || 'zh';\nconst count = preparedData.contact_count;\nlet responseText;\n\nif (count === 0) {\n  responseText = lang === 'zh' \n    ? '沒有找到符合條件的聯絡人。' \n    : 'No contacts found matching your criteria.';\n} else if (count === 1) {\n  const name = formattedContacts[0].full_name || '';\n  const company = formattedContacts[0].company_name || '';\n  responseText = lang === 'zh'\n    ? `找到 1 位聯絡人：${name}${company ? '（' + company + '）' : ''}`\n    : `Found 1 contact: ${name}${company ? ' (' + company + ')' : ''}`;\n} else {\n  responseText = lang === 'zh'\n    ? `找到 ${count} 位聯絡人。`\n    : `Found ${count} contacts.`;\n}\n\nreturn [{\n  json: {\n    success: true,\n    response_text: responseText,\n    contacts: formattedContacts,\n    contact_count: count,\n    intent: preparedData.intent\n  }\n}];"
      },
      "id": "build-response",
      "name": "Build API Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2000, 300]
    }
  ],
  "connections": {
    "Webhook - Chat API": {
      "main": [
        [
          {
            "node": "Validate JWT & Extract Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate JWT & Extract Input": {
      "main": [
        [
          {
            "node": "OpenAI - Analyze Intent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Analyze Intent": {
      "main": [
        [
          {
            "node": "Parse Intent & Sanitize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Intent & Sanitize": {
      "main": [
        [
          {
            "node": "Build Parameterized Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Parameterized Query": {
      "main": [
        [
          {
            "node": "Supabase - Query Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase - Query Contacts": {
      "main": [
        [
          {
            "node": "Prepare Response Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Response Data": {
      "main": [
        [
          {
            "node": "Build API Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build API Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "ReMeet",
      "createdAt": "2026-01-13T00:00:00.000Z",
      "updatedAt": "2026-01-13T00:00:00.000Z"
    },
    {
      "name": "AI Chat",
      "createdAt": "2026-01-13T00:00:00.000Z",
      "updatedAt": "2026-01-13T00:00:00.000Z"
    },
    {
      "name": "Security Updated",
      "createdAt": "2026-01-15T00:00:00.000Z",
      "updatedAt": "2026-01-15T00:00:00.000Z"
    }
  ],
  "pinData": {}
}
