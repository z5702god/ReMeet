{
  "name": "ReMeet AI Chat",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "api/chat",
        "responseMode": "responseNode",
        "options": {
          "rawBody": false
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook - Chat API",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "remeet-chat"
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// JWT TOKEN VALIDATION & INPUT EXTRACTION\n// ===========================================\n// Security: Validate Supabase JWT and extract user_id from token\n// This prevents user_id spoofing attacks\n\n// Get request data\nconst headers = $input.first().json.headers;\nconst body = $input.first().json.body;\n\n// Extract Authorization header\nconst authHeader = headers.authorization || headers.Authorization || '';\nconst token = authHeader.replace('Bearer ', '');\n\nif (!token) {\n  throw new Error('Missing Authorization header. Please provide a valid Supabase JWT token.');\n}\n\n// Decode JWT (without full verification - Supabase handles that)\n// In production, you should verify the signature using Supabase JWT secret\ntry {\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw new Error('Invalid JWT format');\n  }\n  \n  // Decode payload (base64url to base64, then decode)\n  const base64Payload = parts[1].replace(/-/g, '+').replace(/_/g, '/');\n  const payload = JSON.parse(Buffer.from(base64Payload, 'base64').toString('utf8'));\n  \n  // Check expiration\n  const now = Math.floor(Date.now() / 1000);\n  if (payload.exp && payload.exp < now) {\n    throw new Error('JWT token has expired');\n  }\n  \n  // Extract user_id from 'sub' claim (Supabase standard)\n  const user_id = payload.sub;\n  if (!user_id) {\n    throw new Error('Invalid JWT: missing sub claim');\n  }\n  \n  // Validate UUID format to prevent injection\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n  if (!uuidRegex.test(user_id)) {\n    throw new Error('Invalid user_id format');\n  }\n  \n  return [{\n    json: {\n      user_id: user_id,\n      message: body.message || '',\n      today: new Date().toISOString().split('T')[0],\n      jwt_valid: true\n    }\n  }];\n  \n} catch (e) {\n  throw new Error('JWT validation failed: ' + e.message);\n}"
      },
      "id": "validate-jwt",
      "name": "Validate JWT & Extract Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "model": "gpt-4o-mini",
        "options": {
          "temperature": 0,
          "maxTokens": 500
        },
        "messages": {
          "values": [
            {
              "role": "system",
              "content": "你是 ReMeet app 的 AI 助手，專門幫用戶查找他們的商務聯絡人。\n\n根據用戶的訊息，分析他們的意圖並輸出 JSON 格式：\n\n```json\n{\n  \"intent\": \"search_contact\" | \"list_recent\" | \"search_by_event\" | \"search_by_company\" | \"search_by_location\" | \"search_by_date\" | \"need_followup\" | \"general_question\",\n  \"search_params\": {\n    \"name\": \"姓名關鍵字（如有）\",\n    \"company\": \"公司名關鍵字（如有）\",\n    \"location\": \"地點關鍵字（如有）\",\n    \"event_name\": \"活動名稱（如有）\",\n    \"date_start\": \"YYYY-MM-DD（如有時間範圍）\",\n    \"date_end\": \"YYYY-MM-DD（如有時間範圍）\"\n  },\n  \"requires_db_query\": true,\n  \"user_language\": \"zh\" | \"en\"\n}\n```\n\n重要規則：\n1. 今天日期是 {{ $json.today }}\n2. 「上個月」= 上個月的第一天到最後一天\n3. 「最近」= 過去 30 天\n4. 「上週」= 過去 7 天\n5. 如果用戶用中文，設 user_language 為 \"zh\"；用英文則設為 \"en\"\n6. 只輸出 JSON，不要有其他文字"
            },
            {
              "role": "user",
              "content": "={{ $json.message }}"
            }
          ]
        }
      },
      "id": "openai-intent",
      "name": "OpenAI - Analyze Intent",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.5,
      "position": [680, 300],
      "credentials": {
        "openAiApi": {
          "id": "So0TGwMDsXWcYGBb",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// PARSE INTENT & SANITIZE SEARCH PARAMS\n// ===========================================\n// Security: Sanitize all user inputs to prevent SQL injection\n\nconst response = $input.first().json;\nlet intentData;\n\ntry {\n  let content = response.message?.content || response.choices?.[0]?.message?.content || '';\n  content = content.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n  intentData = JSON.parse(content);\n} catch (e) {\n  intentData = {\n    intent: 'search_contact',\n    search_params: {},\n    requires_db_query: true,\n    user_language: 'en'\n  };\n}\n\n// Get original input data\nconst originalInput = $('Validate JWT & Extract Input').first().json;\n\n// ===========================================\n// INPUT SANITIZATION FUNCTION\n// ===========================================\nfunction sanitizeInput(input) {\n  if (!input || typeof input !== 'string') return null;\n  \n  // Remove any SQL injection attempts\n  // Remove: quotes, semicolons, comments, and SQL keywords in dangerous positions\n  let sanitized = input\n    .replace(/['\"`;]/g, '')           // Remove quotes and semicolons\n    .replace(/--/g, '')               // Remove SQL comments\n    .replace(/\\/\\*/g, '')             // Remove block comment start\n    .replace(/\\*\\//g, '')             // Remove block comment end\n    .replace(/\\\\x[0-9a-fA-F]+/g, '') // Remove hex escapes\n    .replace(/\\\\u[0-9a-fA-F]+/g, '') // Remove unicode escapes\n    .trim();\n  \n  // Limit length to prevent overflow attacks\n  if (sanitized.length > 100) {\n    sanitized = sanitized.substring(0, 100);\n  }\n  \n  return sanitized || null;\n}\n\n// Sanitize date format (must be YYYY-MM-DD)\nfunction sanitizeDate(dateStr) {\n  if (!dateStr || typeof dateStr !== 'string') return null;\n  const dateRegex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!dateRegex.test(dateStr)) return null;\n  \n  // Additional validation: check if it's a valid date\n  const date = new Date(dateStr);\n  if (isNaN(date.getTime())) return null;\n  \n  return dateStr;\n}\n\n// Sanitize all search parameters\nconst searchParams = intentData.search_params || {};\nconst sanitizedParams = {\n  name: sanitizeInput(searchParams.name),\n  company: sanitizeInput(searchParams.company),\n  location: sanitizeInput(searchParams.location),\n  event_name: sanitizeInput(searchParams.event_name),\n  date_start: sanitizeDate(searchParams.date_start),\n  date_end: sanitizeDate(searchParams.date_end)\n};\n\nreturn [{\n  json: {\n    user_id: originalInput.user_id,\n    message: originalInput.message,\n    today: originalInput.today,\n    intent: intentData.intent,\n    search_params: sanitizedParams,\n    requires_db_query: intentData.requires_db_query !== false,\n    user_language: intentData.user_language || 'en'\n  }\n}];"
      },
      "id": "parse-intent",
      "name": "Parse Intent & Sanitize",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "// ===========================================\n// BUILD SAFE QUERY WITH INLINE VALUES\n// ===========================================\n// Security: All inputs have been sanitized in previous step\n// user_id is validated as UUID, other params have dangerous chars removed\n\nconst data = $input.first().json;\n\n// Escape single quotes for SQL safety (double them)\nfunction escapeSql(str) {\n  if (!str) return null;\n  return str.replace(/'/g, \"''\");\n}\n\n// Build the query with inline values (already sanitized)\nconst userId = escapeSql(data.user_id);\n\nlet query = `\nWITH contact_data AS (\n  SELECT \n    c.id,\n    c.full_name,\n    c.title,\n    c.email,\n    c.phone,\n    c.is_favorite,\n    c.created_at,\n    co.name as company_name,\n    co.industry as company_industry\n  FROM contacts c\n  LEFT JOIN companies co ON c.company_id = co.id\n  WHERE c.user_id = '${userId}'::uuid\n),\nmeeting_data AS (\n  SELECT \n    mc.contact_id,\n    mc.meeting_date,\n    mc.location_name,\n    mc.event_name,\n    mc.occasion_type,\n    mc.relationship_type,\n    mc.notes,\n    mc.follow_up_required,\n    mc.follow_up_date\n  FROM meeting_contexts mc\n  WHERE mc.user_id = '${userId}'::uuid\n)\nSELECT \n  cd.*,\n  md.meeting_date,\n  md.location_name,\n  md.event_name,\n  md.occasion_type,\n  md.relationship_type,\n  md.notes as meeting_notes,\n  md.follow_up_required,\n  md.follow_up_date\nFROM contact_data cd\nLEFT JOIN meeting_data md ON cd.id = md.contact_id\nWHERE 1=1\n`;\n\n// Add optional filters with escaped values\nif (data.search_params.name) {\n  query += ` AND cd.full_name ILIKE '%${escapeSql(data.search_params.name)}%'`;\n}\n\nif (data.search_params.company) {\n  query += ` AND cd.company_name ILIKE '%${escapeSql(data.search_params.company)}%'`;\n}\n\nif (data.search_params.location) {\n  query += ` AND md.location_name ILIKE '%${escapeSql(data.search_params.location)}%'`;\n}\n\nif (data.search_params.event_name) {\n  query += ` AND md.event_name ILIKE '%${escapeSql(data.search_params.event_name)}%'`;\n}\n\nif (data.search_params.date_start) {\n  query += ` AND md.meeting_date >= '${escapeSql(data.search_params.date_start)}'::date`;\n}\n\nif (data.search_params.date_end) {\n  query += ` AND md.meeting_date <= '${escapeSql(data.search_params.date_end)}'::date`;\n}\n\nif (data.intent === 'need_followup') {\n  query += ` AND md.follow_up_required = true`;\n}\n\nquery += `\nORDER BY \n  CASE WHEN md.meeting_date IS NOT NULL THEN md.meeting_date ELSE cd.created_at END DESC\nLIMIT 20`;\n\nreturn [{\n  json: {\n    ...data,\n    query: query\n  }\n}];"
      },
      "id": "build-query",
      "name": "Build Parameterized Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.query }}"
      },
      "id": "supabase-query",
      "name": "Supabase - Query Contacts",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1340, 300],
      "credentials": {
        "postgres": {
          "id": "WjqzcbGnUEsK5Wxs",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepare data for response generation\nconst intentData = $('Build Parameterized Query').first().json;\nconst queryResults = $input.all().map(item => item.json);\n\n// Deduplicate contacts (may have multiple meeting contexts)\nconst contactMap = new Map();\nfor (const row of queryResults) {\n  if (!row.id) continue;\n  \n  if (!contactMap.has(row.id)) {\n    contactMap.set(row.id, {\n      id: row.id,\n      full_name: row.full_name,\n      title: row.title,\n      email: row.email,\n      phone: row.phone,\n      company_name: row.company_name,\n      is_favorite: row.is_favorite,\n      meeting_contexts: []\n    });\n  }\n  \n  if (row.meeting_date || row.event_name || row.location_name) {\n    contactMap.get(row.id).meeting_contexts.push({\n      meeting_date: row.meeting_date,\n      location_name: row.location_name,\n      event_name: row.event_name,\n      occasion_type: row.occasion_type,\n      relationship_type: row.relationship_type,\n      notes: row.meeting_notes,\n      follow_up_required: row.follow_up_required,\n      follow_up_date: row.follow_up_date\n    });\n  }\n}\n\nconst contacts = Array.from(contactMap.values());\n\nreturn [{\n  json: {\n    user_id: intentData.user_id,\n    message: intentData.message,\n    intent: intentData.intent,\n    search_params: intentData.search_params,\n    user_language: intentData.user_language,\n    contacts: contacts,\n    contact_count: contacts.length\n  }\n}];"
      },
      "id": "prepare-response",
      "name": "Prepare Response Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "jsCode": "// Build final API response - 直接返回名片資料，不使用 AI 生成回覆\nconst preparedData = $input.first().json;\n\n// Format contacts for iOS app\nconst formattedContacts = preparedData.contacts.map(c => ({\n  id: c.id,\n  full_name: c.full_name,\n  title: c.title,\n  email: c.email,\n  phone: c.phone,\n  company_name: c.company_name,\n  is_favorite: c.is_favorite,\n  meeting_context: c.meeting_contexts?.[0] ? {\n    date: c.meeting_contexts[0].meeting_date,\n    location: c.meeting_contexts[0].location_name,\n    event: c.meeting_contexts[0].event_name,\n    occasion_type: c.meeting_contexts[0].occasion_type,\n    relationship_type: c.meeting_contexts[0].relationship_type\n  } : null\n}));\n\n// 根據語言和結果數量生成簡單回覆\nconst lang = preparedData.user_language || 'zh';\nconst count = preparedData.contact_count;\nlet responseText;\n\nif (count === 0) {\n  responseText = lang === 'zh' \n    ? '沒有找到符合條件的聯絡人。' \n    : 'No contacts found matching your criteria.';\n} else if (count === 1) {\n  const name = formattedContacts[0].full_name || '';\n  const company = formattedContacts[0].company_name || '';\n  responseText = lang === 'zh'\n    ? `找到 1 位聯絡人：${name}${company ? '（' + company + '）' : ''}`\n    : `Found 1 contact: ${name}${company ? ' (' + company + ')' : ''}`;\n} else {\n  responseText = lang === 'zh'\n    ? `找到 ${count} 位聯絡人。`\n    : `Found ${count} contacts.`;\n}\n\nreturn [{\n  json: {\n    success: true,\n    response_text: responseText,\n    contacts: formattedContacts,\n    contact_count: count,\n    intent: preparedData.intent\n  }\n}];"
      },
      "id": "build-response",
      "name": "Build API Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2000, 300]
    }
  ],
  "connections": {
    "Webhook - Chat API": {
      "main": [
        [
          {
            "node": "Validate JWT & Extract Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate JWT & Extract Input": {
      "main": [
        [
          {
            "node": "OpenAI - Analyze Intent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI - Analyze Intent": {
      "main": [
        [
          {
            "node": "Parse Intent & Sanitize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Intent & Sanitize": {
      "main": [
        [
          {
            "node": "Build Parameterized Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Parameterized Query": {
      "main": [
        [
          {
            "node": "Supabase - Query Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supabase - Query Contacts": {
      "main": [
        [
          {
            "node": "Prepare Response Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Response Data": {
      "main": [
        [
          {
            "node": "Build API Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build API Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "name": "ReMeet",
      "createdAt": "2026-01-13T00:00:00.000Z",
      "updatedAt": "2026-01-13T00:00:00.000Z"
    },
    {
      "name": "AI Chat",
      "createdAt": "2026-01-13T00:00:00.000Z",
      "updatedAt": "2026-01-13T00:00:00.000Z"
    },
    {
      "name": "Security Updated",
      "createdAt": "2026-01-15T00:00:00.000Z",
      "updatedAt": "2026-01-15T00:00:00.000Z"
    }
  ],
  "pinData": {}
}
